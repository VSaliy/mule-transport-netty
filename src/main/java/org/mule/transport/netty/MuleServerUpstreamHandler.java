/*
 * $Id$
 * --------------------------------------------------------------------------------------
 * Copyright (c) MuleSoft, Inc.  All rights reserved.  http://www.mulesoft.com
 *
 * The software in this package is published under the terms of the CPAL v1.0
 * license, a copy of which has been included with this distribution in the
 * LICENSE.txt file.
 */

package org.mule.transport.netty;

import org.mule.api.ExceptionPayload;
import org.mule.api.MuleEvent;
import org.mule.api.MuleMessage;
import org.mule.api.MuleSession;
import org.mule.api.transport.SessionHandler;
import org.mule.session.LegacySessionHandler;

import java.io.InputStream;
import java.nio.charset.Charset;
import java.util.concurrent.atomic.AtomicLong;
import java.util.logging.Logger;

import org.apache.commons.lang.SerializationException;
import org.jboss.netty.buffer.ChannelBuffer;
import org.jboss.netty.buffer.ChannelBufferInputStream;
import org.jboss.netty.buffer.ChannelBuffers;
import org.jboss.netty.channel.Channel;
import org.jboss.netty.channel.ChannelFutureListener;
import org.jboss.netty.channel.ChannelHandlerContext;
import org.jboss.netty.channel.ExceptionEvent;
import org.jboss.netty.channel.MessageEvent;
import org.jboss.netty.channel.SimpleChannelUpstreamHandler;
import org.jboss.netty.handler.codec.string.StringEncoder;
import org.jboss.netty.handler.stream.ChunkedStream;
import org.jboss.netty.handler.stream.ChunkedWriteHandler;

/**
 * TODO handler/mule receiver worker
 */
public class MuleServerUpstreamHandler extends SimpleChannelUpstreamHandler
{

    private static final Logger logger = Logger.getLogger(MuleServerUpstreamHandler.class.getName());

    private final AtomicLong transferredBytes = new AtomicLong();
    private NettyMessageReceiver receiver;

    public MuleServerUpstreamHandler(NettyMessageReceiver receiver)
    {
        this.receiver = receiver;
    }

    public long getTransferredBytes()
    {
        return transferredBytes.get();
    }

    @Override
    public void messageReceived(
            ChannelHandlerContext ctx, MessageEvent event)
    {
        // Send back the received message to the remote peer.
        final ChannelBuffer buffer = (ChannelBuffer) event.getMessage();
        transferredBytes.addAndGet(buffer.readableBytes());

        final ChannelBuffer copy = ChannelBuffers.copiedBuffer(buffer);
        final String s = copy.toString(Charset.forName(receiver.getEndpoint().getEncoding()));

        final Channel channel = event.getChannel();
        try
        {
            final MuleMessage muleMessage = receiver.createMuleMessage(new ChannelBufferInputStream(buffer), receiver.getEndpoint().getEncoding());
            SessionHandler handler = receiver.getEndpoint().getConnector().getSessionHandler();
            MuleSession session;
            try
            {
                session = handler.retrieveSessionInfoFromMessage(muleMessage);
            }
            catch (SerializationException e)
            {
                // EE-1820 Support message headers generated by previous Mule versions
                session = new LegacySessionHandler().retrieveSessionInfoFromMessage(muleMessage);
            }
            if (receiver.getEndpoint().getExchangePattern().hasResponse())
            {
                final MuleEvent result = receiver.routeMessage(muleMessage, session, null, null);

                final MuleMessage message = result.getMessage();
                final ExceptionPayload exceptionPayload = message.getExceptionPayload();
                if (exceptionPayload == null)
                {
                    if (message.getPayload() instanceof InputStream)
                    {
                        final ChunkedStream stream = new ChunkedStream(message.getPayload(InputStream.class));
                        channel.getPipeline().addLast("streamer", new ChunkedWriteHandler());
                        channel.write(stream).addListener(ChannelFutureListener.CLOSE);
                    }
                    else
                    {
                        final ChannelBuffer out = ChannelBuffers.wrappedBuffer(message.getPayloadAsBytes());
                        channel.write(out).addListener(ChannelFutureListener.CLOSE);
                    }
                }
                else
                {
                    // send an error message from the root exception
                    channel.getPipeline().addLast("encoder", new StringEncoder(Charset.forName(receiver.getEndpoint().getEncoding())));
                    channel.write(exceptionPayload.getRootException().getMessage()).addListener(ChannelFutureListener.CLOSE);
                }
            }
            else
            {
                channel.close();
                receiver.routeMessage(muleMessage, session, null, null);
            }
        }
        catch (Exception e)
        {
            e.printStackTrace();
            channel.close();
        }

    }

    @Override
    public void exceptionCaught(
            ChannelHandlerContext ctx, ExceptionEvent e)
    {
        //receiver.getFlowConstruct().getExceptionListener().handleException(e)
        e.getCause().printStackTrace();
        e.getChannel().close();
    }
}
